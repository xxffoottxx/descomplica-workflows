{
  "name": "Sugestões de Venda - Standard Tier",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "hardware-demo",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "66c7721e-9841-40be-9eef-89eb25cc7f1b",
      "name": "Webhook - Cart Info",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -608,
        304
      ],
      "webhookId": "hardware-demo-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Cache Check with Request Locking + Performance Metrics + Request Superseding\nif (typeof global.suggestionCache === 'undefined') {\n  global.suggestionCache = {};\n}\nif (typeof global.processingRequests === 'undefined') {\n  global.processingRequests = {};\n}\nif (typeof global.performanceMetrics === 'undefined') {\n  global.performanceMetrics = {\n    total_requests: 0,\n    cache_hits: 0,\n    cache_misses: 0,\n    wait_requests: 0,\n    total_processing_time: 0,\n    superseded_requests: 0\n  };\n}\nif (typeof global.newestRequests === 'undefined') {\n  global.newestRequests = {};\n}\n\nconst webhookData = $input.first().json;\nconst body = webhookData.body || webhookData;\n\nconst sessionId = body.session_id || 'unknown';\nconst cartHash = body.cart_hash || 'unknown';\nconst requestId = body.request_id || 'unknown';\nconst isPrefetch = body.prefetch || false;\nconst cartEmpty = body.cart_empty || false;\nconst customerId = body.customer_id || 'demo';\n\nconst cacheKey = `${sessionId}:${cartHash}`;\nconst now = Date.now();\nconst TTL = 300000;\nconst PROCESSING_TTL = 60000;\n\nglobal.performanceMetrics.total_requests++;\n\nif (cartEmpty) {\n  console.log(`[Cache] Cart empty - clearing session ${sessionId}`);\n  Object.keys(global.suggestionCache).forEach(key => {\n    if (key.startsWith(sessionId + ':')) delete global.suggestionCache[key];\n  });\n  Object.keys(global.processingRequests).forEach(key => {\n    if (key.startsWith(sessionId + ':')) delete global.processingRequests[key];\n  });\n  delete global.newestRequests[sessionId];\n  \n  return {\n    json: {\n      success: false,\n      suggestions: [],\n      message: 'Cart empty',\n      _skipProcessing: true,\n      _cacheHit: false\n    }\n  };\n}\n\nconst previousNewest = global.newestRequests[sessionId];\nglobal.newestRequests[sessionId] = { request_id: requestId, cart_hash: cartHash, timestamp: now, is_prefetch: isPrefetch };\n\nif (previousNewest && previousNewest.cart_hash !== cartHash) {\n  global.performanceMetrics.superseded_requests++;\n  const oldCacheKey = `${sessionId}:${previousNewest.cart_hash}`;\n  delete global.suggestionCache[oldCacheKey];\n  delete global.processingRequests[oldCacheKey];\n}\n\n// Cleanup expired entries\nObject.keys(global.suggestionCache).forEach(key => {\n  if (now - global.suggestionCache[key].timestamp > TTL) delete global.suggestionCache[key];\n});\nObject.keys(global.processingRequests).forEach(key => {\n  if (now - global.processingRequests[key].timestamp > PROCESSING_TTL) delete global.processingRequests[key];\n});\nObject.keys(global.newestRequests).forEach(key => {\n  if (now - global.newestRequests[key].timestamp > TTL) delete global.newestRequests[key];\n});\n\nconst cached = global.suggestionCache[cacheKey];\nif (cached && now - cached.timestamp < TTL) {\n  global.performanceMetrics.cache_hits++;\n  return {\n    json: {\n      ...cached.data,\n      cached: true,\n      cache_age_seconds: Math.round((now - cached.timestamp) / 1000),\n      _cacheHit: true,\n      _skipProcessing: true\n    }\n  };\n}\n\nconst processing = global.processingRequests[cacheKey];\nif (processing && now - processing.timestamp < PROCESSING_TTL) {\n  global.performanceMetrics.wait_requests++;\n  return {\n    json: {\n      ...webhookData,\n      cacheKey: cacheKey,\n      timestamp: now,\n      _cacheHit: false,\n      _skipProcessing: true,\n      _waitForProcessing: true,\n      _processingRequestId: processing.request_id\n    }\n  };\n}\n\nglobal.processingRequests[cacheKey] = { request_id: requestId, timestamp: now, is_prefetch: isPrefetch };\n\nreturn {\n  json: {\n    ...webhookData,\n    cacheKey: cacheKey,\n    timestamp: now,\n    _cacheHit: false,\n    _skipProcessing: false,\n    _sessionId: sessionId,\n    _requestId: requestId,\n    _customerId: customerId\n  }\n};"
      },
      "id": "712b3683-873c-4d72-8348-f3d1b71aa730",
      "name": "Check Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        304
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._skipProcessing}}",
              "value2": true
            }
          ]
        }
      },
      "id": "ff0aee87-7dc8-4036-b758-64b4b5896742",
      "name": "Skip Processing?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -208,
        304
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._cacheHit}}",
              "value2": true
            }
          ]
        }
      },
      "id": "f3cb63e9-63d4-42fd-89ba-b5b7d25807d8",
      "name": "Cache Hit or Wait?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        0,
        160
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "X-Cache-Status",
                "value": "HIT"
              }
            ]
          }
        }
      },
      "id": "f92af26a-c311-490d-a3c3-82222f986132",
      "name": "Return Cached",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ]
    },
    {
      "parameters": {
        "jsCode": "// Poll for result - another request is processing\nconst cacheKey = $json.cacheKey;\nconst requestId = $json.body?.request_id || $json.request_id || 'unknown';\n\nfor (let i = 0; i < 80; i++) {\n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  if (global.suggestionCache && global.suggestionCache[cacheKey]) {\n    const cached = global.suggestionCache[cacheKey];\n    const now = Date.now();\n    if (now - cached.timestamp < 60000) {\n      return {\n        json: {\n          ...cached.data,\n          cached: true,\n          cache_age_seconds: Math.round((now - cached.timestamp) / 1000),\n          waited_ms: (i + 1) * 500\n        }\n      };\n    }\n  }\n}\n\nreturn {\n  json: {\n    success: false,\n    suggestions: [],\n    error: 'Request timeout',\n    cached: false\n  }\n};"
      },
      "id": "e6cdd18e-7a3b-4c13-b54a-b501cedcba19",
      "name": "Wait for Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id, name, description, price, category, subcategory,\n  sku, in_stock, stock_quantity, compatibility_tags, image_url\nFROM demo_products\nWHERE in_stock = true\nORDER BY category, name",
        "options": {}
      },
      "id": "e2e926d2-dffb-4a48-a245-7b95dadaf51c",
      "name": "Get Products",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        0,
        464
      ],
      "credentials": {
        "postgres": {
          "id": "acM3cJuEGq6fcPDx",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "url": "https://api.openweathermap.org/data/2.5/weather",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "lat",
              "value": "38.7223"
            },
            {
              "name": "lon",
              "value": "-9.1393"
            },
            {
              "name": "appid",
              "value": "{{$env.OPENWEATHER_API_KEY}}"
            },
            {
              "name": "units",
              "value": "metric"
            }
          ]
        },
        "options": {
          "timeout": 500
        }
      },
      "id": "cb95cc19-b281-4bcb-854b-b298a0543316",
      "name": "Get Weather",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        0,
        608
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  p.id, p.name, p.category, ph.quantity, ph.purchase_date\nFROM purchase_history ph\nJOIN demo_products p ON ph.product_id = p.id\nWHERE ph.customer_id = '{{ $node[\"Check Cache\"].json._customerId }}'\nORDER BY ph.purchase_date DESC\nLIMIT 20",
        "options": {}
      },
      "id": "1a1aee43-2f31-48f1-961a-1d5fad0a2db5",
      "name": "Get Purchase History",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        0,
        752
      ],
      "credentials": {
        "postgres": {
          "id": "acM3cJuEGq6fcPDx",
          "name": "Postgres account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Merge all context: Products, Weather, Purchase History, Date/Season\nconst webhookData = $node[\"Webhook - Cart Info\"].json;\nconst checkCacheData = $node[\"Check Cache\"].json;\nconst inputData = webhookData.body || webhookData;\n\n// Extract cart items\nlet cartItems = inputData.body?.cart_items || inputData.cart_items || [];\n\n// Get products from database\nlet allProducts = [];\nconst allInputs = $input.all();\nallInputs.forEach(inputItem => {\n  const data = inputItem.json;\n  if (data && data.id && data.name && data.price && data.category) {\n    allProducts.push(data);\n  }\n});\n\n// Get weather data (with fallback)\nlet weather = {\n  temp: 20,\n  condition: 'unknown',\n  is_raining: false,\n  is_cold: false,\n  is_hot: false\n};\n\ntry {\n  const weatherNode = $node[\"Get Weather\"];\n  if (weatherNode && weatherNode.json && weatherNode.json.main) {\n    const w = weatherNode.json;\n    weather = {\n      temp: Math.round(w.main.temp),\n      condition: w.weather?.[0]?.main || 'unknown',\n      is_raining: ['Rain', 'Drizzle', 'Thunderstorm'].includes(w.weather?.[0]?.main),\n      is_cold: w.main.temp < 10,\n      is_hot: w.main.temp > 30,\n      humidity: w.main.humidity,\n      description: w.weather?.[0]?.description\n    };\n  }\n} catch (e) {\n  console.log('Weather fetch failed, using fallback:', e.message);\n}\n\n// Get purchase history (with fallback)\nlet purchaseHistory = [];\ntry {\n  const historyNode = $node[\"Get Purchase History\"];\n  if (historyNode && Array.isArray(historyNode.json)) {\n    purchaseHistory = historyNode.json;\n  } else if (historyNode && historyNode.json && historyNode.json.id) {\n    purchaseHistory = [historyNode.json];\n  }\n} catch (e) {\n  console.log('Purchase history fetch failed:', e.message);\n}\n\n// Compute date/season context\nconst now = new Date();\nconst month = now.getMonth() + 1;\nconst season = month >= 3 && month <= 5 ? 'spring' :\n               month >= 6 && month <= 8 ? 'summer' :\n               month >= 9 && month <= 11 ? 'autumn' : 'winter';\nconst isWeekend = [0, 6].includes(now.getDay());\nconst isHolidaySeason = month === 12 || month === 1;\n\nconst dateContext = {\n  season,\n  month,\n  isWeekend,\n  isHolidaySeason,\n  dayOfWeek: now.toLocaleDateString('pt-PT', { weekday: 'long' })\n};\n\nconsole.log('[Context] Weather:', JSON.stringify(weather));\nconsole.log('[Context] Season:', season, '| Weekend:', isWeekend);\nconsole.log('[Context] Purchase history items:', purchaseHistory.length);\n\n// Build product lookup\nconst productMap = {};\nallProducts.forEach(p => { productMap[p.id] = p; });\n\n// Analyze cart\nconst cartProductIds = cartItems.map(item => item.product_id || item.id);\nconst cartCategories = [...new Set(cartItems.map(item => {\n  const product = productMap[item.product_id || item.id];\n  return product?.category || 'unknown';\n}))].filter(c => c !== 'unknown');\n\nconst cartTotal = cartItems.reduce((sum, item) => sum + ((item.price || 0) * (item.quantity || 1)), 0);\n\nconst cartProductDetails = cartItems.map(item => {\n  const product = productMap[item.product_id || item.id];\n  return {\n    id: item.product_id || item.id,\n    name: item.product_name || item.name || product?.name,\n    category: product?.category,\n    compatibility_tags: product?.compatibility_tags || [],\n    quantity: item.quantity || 1\n  };\n});\n\n// Find compatible products with priority\nconst allCartTags = new Set();\ncartProductDetails.forEach(item => {\n  (item.compatibility_tags || []).forEach(tag => allCartTags.add(tag));\n});\n\nlet compatibleProducts = allProducts.filter(p => {\n  if (cartProductIds.includes(p.id)) return false;\n  const productTags = p.compatibility_tags || [];\n  return productTags.some(tag => allCartTags.has(tag));\n});\n\n// Priority: Safety for power tools\nconst hasPowerTools = cartItems.some(item => {\n  const prod = productMap[item.product_id || item.id];\n  return prod?.category === 'Power Tools';\n});\n\nif (hasPowerTools) {\n  const safetyProducts = allProducts.filter(p => p.category === 'Safety' && !cartProductIds.includes(p.id));\n  const existingIds = new Set(compatibleProducts.map(p => p.id));\n  safetyProducts.forEach(p => {\n    if (!existingIds.has(p.id)) compatibleProducts.unshift(p);\n  });\n}\n\n// Weather-based suggestions\nif (weather.is_cold || weather.is_raining) {\n  // Prioritize gloves, protective gear for cold/wet weather\n  const protectiveGear = allProducts.filter(p => \n    p.subcategory?.includes('Proteção') && !cartProductIds.includes(p.id)\n  );\n  const existingIds = new Set(compatibleProducts.map(p => p.id));\n  protectiveGear.forEach(p => {\n    if (!existingIds.has(p.id)) compatibleProducts.push(p);\n  });\n}\n\n// Avoid recently purchased items\nconst recentlyPurchasedIds = new Set(purchaseHistory.slice(0, 10).map(h => h.id));\ncompatibleProducts = compatibleProducts.filter(p => !recentlyPurchasedIds.has(p.id));\n\ncompatibleProducts = compatibleProducts.slice(0, 30);\n\n// Detect project type\nlet projectType = 'general';\nif (hasPowerTools) projectType = 'power_tool_project';\nif (cartItems.some(i => productMap[i.product_id || i.id]?.category === 'Paint')) projectType = 'painting_project';\n\nconst customerId = inputData.body?.customer_id || inputData.customer_id || 'demo';\nconst sessionId = inputData.body?.session_id || inputData.session_id || 'demo-' + Date.now();\n\nconst contextData = {\n  cart_items: cartProductDetails,\n  cart_product_ids: cartProductIds,\n  cart_categories: cartCategories,\n  cart_total: cartTotal.toFixed(2),\n  project_type: projectType,\n  compatible_products: compatibleProducts,\n  weather: weather,\n  date_context: dateContext,\n  purchase_history: purchaseHistory.slice(0, 5),\n  customer_id: customerId,\n  session_id: sessionId,\n  timestamp: new Date().toISOString()\n};\n\n// Enhanced Ollama prompt with weather and history context\nconst ollamaRequest = {\n  model: \"llama3.2\",\n  messages: [\n    {\n      role: \"system\",\n      content: `És um assistente de vendas de ferramentas. Analisa o carrinho do cliente e sugere 5 produtos complementares.\n\nCONTEXTO DISPONÍVEL:\n- Carrinho atual do cliente\n- Condições meteorológicas (temp: ${weather.temp}°C, ${weather.condition})\n- Estação: ${season}\n- Histórico de compras recente\n\nCRITÉRIOS DE SELEÇÃO:\n1. Ferramentas/materiais em falta para completar o projeto\n2. Equipamento de segurança (PRIORIDADE ALTA se ferramentas elétricas)\n3. Considera o clima: frio → luvas/proteção; chuva → impermeáveis\n4. Evita sugerir produtos já comprados recentemente\n5. Consumíveis e acessórios necessários\n\nREGRAS OBRIGATÓRIAS:\n- Usa APENAS product_id da lista compatible_products\n- NÃO inventes IDs de produtos\n- Atribui confidence (0.0-1.0) baseado na relevância\n\nRETORNA APENAS JSON VÁLIDO:\n{\n  \"suggestions\": [\n    {\n      \"product_id\": <id exato>,\n      \"product_name\": \"<nome exato>\",\n      \"reason\": \"<razão curta>\",\n      \"confidence\": <0.0-1.0>\n    }\n  ]\n}`\n    },\n    {\n      role: \"user\",\n      content: JSON.stringify(contextData)\n    }\n  ],\n  stream: false,\n  format: \"json\",\n  options: {\n    temperature: 0.4,\n    num_predict: 2500\n  }\n};\n\nreturn {\n  contextData: contextData,\n  ollamaRequest: ollamaRequest\n};"
      },
      "id": "5934aae5-b8a7-4a40-bfd1-2b73ee8cb481",
      "name": "Merge Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        304,
        464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Check if request has been superseded\nconst checkCacheNode = $node[\"Check Cache\"].json;\nconst sessionId = checkCacheNode._sessionId || 'unknown';\nconst requestId = checkCacheNode._requestId || 'unknown';\nconst cartHash = checkCacheNode.body?.cart_hash || 'unknown';\n\nconst newestRequest = global.newestRequests && global.newestRequests[sessionId];\n\nif (newestRequest && newestRequest.request_id !== requestId) {\n  const cacheKey = `${sessionId}:${cartHash}`;\n  if (global.processingRequests && global.processingRequests[cacheKey]) {\n    delete global.processingRequests[cacheKey];\n  }\n  \n  return {\n    json: {\n      success: false,\n      suggestions: [],\n      message: 'Request superseded',\n      superseded: true,\n      _skipOllama: true\n    }\n  };\n}\n\nreturn { json: $json };"
      },
      "id": "2e0459e2-9b32-4b6d-98c3-db9121874e8f",
      "name": "Validate Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        464
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._skipOllama}}",
              "value2": true
            }
          ]
        }
      },
      "id": "3d24af8a-133f-479e-b760-1b764c89e278",
      "name": "Skip Ollama?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        704,
        464
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.ollamaRequest }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "0348de62-9cb5-4086-a369-e72c4a2287a9",
      "name": "Ollama AI",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        912,
        560
      ],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and validate with strict ID checking\nconst prepareNode = $node[\"Merge Context\"].json;\nconst cartData = prepareNode.contextData || prepareNode;\n\nconst productMap = {};\ncartData.compatible_products.forEach(p => {\n  if (p.id && p.name && p.price) productMap[p.id] = p;\n});\n\nconst validProductIds = new Set(cartData.compatible_products.map(p => p.id));\n\nlet suggestions = [];\nlet llmUsed = 'ollama';\n\ntry {\n  const input = $input.first().json;\n  if (input.error) throw new Error('Ollama request failed: ' + input.error.message);\n\n  let ollamaResponse = input;\n  if (input.body) {\n    ollamaResponse = typeof input.body === 'string' ? JSON.parse(input.body) : input.body;\n  }\n\n  if (ollamaResponse.message?.content) {\n    const content = typeof ollamaResponse.message.content === 'string'\n      ? JSON.parse(ollamaResponse.message.content)\n      : ollamaResponse.message.content;\n    suggestions = content.suggestions || [];\n  } else if (ollamaResponse.suggestions) {\n    suggestions = ollamaResponse.suggestions;\n  }\n\n  const enrichedSuggestions = suggestions\n    .map(suggestion => {\n      const productId = parseInt(suggestion.product_id);\n      if (!validProductIds.has(productId)) return null;\n      const product = productMap[productId];\n      if (!product) return null;\n\n      return {\n        product_id: productId,\n        product_name: product.name,\n        description: product.description || '',\n        category: product.category,\n        subcategory: product.subcategory || '',\n        price: parseFloat(product.price),\n        confidence: parseFloat(suggestion.confidence || 0.75),\n        reason: suggestion.reason || '',\n        in_stock: product.in_stock,\n        stock_quantity: product.stock_quantity,\n        sku: product.sku\n      };\n    })\n    .filter(s => s !== null && s.in_stock)\n    .filter((s, i, self) => i === self.findIndex(t => t.product_id === s.product_id))\n    .filter(s => !cartData.cart_product_ids.includes(s.product_id))\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, 5);\n\n  if (enrichedSuggestions.length === 0 && cartData.compatible_products.length > 0) {\n    llmUsed = 'fallback';\n    cartData.compatible_products.slice(0, 3).forEach(product => {\n      const dbProduct = productMap[product.id];\n      if (dbProduct && !cartData.cart_product_ids.includes(product.id)) {\n        enrichedSuggestions.push({\n          product_id: product.id,\n          product_name: dbProduct.name,\n          description: dbProduct.description || '',\n          category: dbProduct.category,\n          subcategory: dbProduct.subcategory || '',\n          price: parseFloat(dbProduct.price),\n          confidence: 0.70,\n          reason: 'Recommended product',\n          in_stock: true,\n          stock_quantity: dbProduct.stock_quantity || 0,\n          sku: dbProduct.sku || ''\n        });\n      }\n    });\n  }\n\n  const suggestedTotal = enrichedSuggestions.reduce((sum, s) => sum + s.price, 0);\n\n  return {\n    success: true,\n    suggestions: enrichedSuggestions,\n    context_used: {\n      weather: cartData.weather,\n      season: cartData.date_context?.season,\n      purchase_history_items: cartData.purchase_history?.length || 0\n    },\n    analytics: {\n      cart_value: parseFloat(cartData.cart_total),\n      suggested_value: parseFloat(suggestedTotal.toFixed(2)),\n      suggestion_count: enrichedSuggestions.length,\n      cart_categories: cartData.cart_categories,\n      project_type: cartData.project_type\n    },\n    metadata: {\n      llm_used: llmUsed,\n      tier: 'standard',\n      generated_at: new Date().toISOString(),\n      session_id: cartData.session_id\n    }\n  };\n\n} catch (error) {\n  console.error('Format Response ERROR:', error.message);\n  return {\n    success: false,\n    suggestions: [],\n    error: error.message,\n    metadata: {\n      llm_used: 'error',\n      tier: 'standard',\n      generated_at: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "b00a1d11-1efc-49ac-b2d8-b2758f4bd87e",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        560
      ]
    },
    {
      "parameters": {
        "jsCode": "// Store result in cache\nif (typeof global.suggestionCache === 'undefined') global.suggestionCache = {};\nif (typeof global.processingRequests === 'undefined') global.processingRequests = {};\nif (typeof global.performanceMetrics === 'undefined') {\n  global.performanceMetrics = { total_requests: 0, cache_hits: 0, cache_misses: 0, wait_requests: 0, total_processing_time: 0 };\n}\n\nconst checkCacheNode = $node[\"Check Cache\"].json;\nconst cacheKey = checkCacheNode.cacheKey;\nconst requestId = checkCacheNode.body?.request_id || checkCacheNode.request_id || 'unknown';\nconst startTime = checkCacheNode.timestamp || Date.now();\nconst processingTime = Date.now() - startTime;\n\nglobal.performanceMetrics.cache_misses++;\nglobal.performanceMetrics.total_processing_time += processingTime;\n\nif (cacheKey && cacheKey !== 'unknown:unknown') {\n  global.suggestionCache[cacheKey] = {\n    data: $json,\n    timestamp: Date.now(),\n    request_id: requestId\n  };\n  \n  if (global.processingRequests[cacheKey]) {\n    delete global.processingRequests[cacheKey];\n  }\n}\n\nreturn { \n  json: {\n    ...$json,\n    cached: false,\n    processing_time_ms: processingTime\n  }\n};"
      },
      "id": "94374c53-e27b-4624-80e2-3537e82799b1",
      "name": "Store in Cache",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        560
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "X-Tier",
                "value": "standard"
              },
              {
                "name": "X-Cache-Status",
                "value": "MISS"
              }
            ]
          }
        }
      },
      "id": "26c93d46-78ce-44d5-a0f3-d4cfe86096fb",
      "name": "Return Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1504,
        464
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Cart Info": {
      "main": [
        [
          {
            "node": "Check Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Cache": {
      "main": [
        [
          {
            "node": "Skip Processing?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Processing?": {
      "main": [
        [
          {
            "node": "Cache Hit or Wait?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Products",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Weather",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Purchase History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Hit or Wait?": {
      "main": [
        [
          {
            "node": "Return Cached",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait for Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Result": {
      "main": [
        [
          {
            "node": "Return Cached",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Products": {
      "main": [
        [
          {
            "node": "Merge Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Weather": {
      "main": [
        [
          {
            "node": "Merge Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Purchase History": {
      "main": [
        [
          {
            "node": "Merge Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Context": {
      "main": [
        [
          {
            "node": "Validate Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Request": {
      "main": [
        [
          {
            "node": "Skip Ollama?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Ollama?": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ollama AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama AI": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Store in Cache",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Cache": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "5c7e4a33-f110-4644-8c12-d86d6fae519b",
  "meta": {
    "instanceId": "0ad473ca5f04731bc02a819377b7037140df61c07ce29e449d14e76e6e995ec1"
  },
  "id": "FKMmq_m3JkvCLKtgGT6VX",
  "tags": [
    {
      "updatedAt": "2026-01-15T00:30:13.181Z",
      "createdAt": "2026-01-15T00:30:13.181Z",
      "id": "hD3oTG7a5mRCEbJF",
      "name": "demo"
    },
    {
      "name": "standard-tier",
      "id": "PsKzv5KTxr5pyjMm",
      "updatedAt": "2026-01-19T17:50:40.668Z",
      "createdAt": "2026-01-19T17:50:40.668Z"
    }
  ]
}